<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pomodoro</title>
  <meta name="theme-color" content="#0a0a0a" />
  <link rel="icon" href="data:," />
  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 + ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for in-browser JSX transform (no build needed) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { height: 100%; background: #0a0a0a; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const DEFAULTS = {
      work: 25,
      short: 5,
      long: 15,
      longEvery: 4,
      autoStart: false,
    };

    const STORAGE_KEY = "pomodoro.settings.v1";
    const STATE_KEY = "pomodoro.state.v1";

    function PomodoroApp() {
      const [settings, setSettings] = useState(() => {
        try {
          const s = localStorage.getItem(STORAGE_KEY);
          return s ? { ...DEFAULTS, ...JSON.parse(s) } : DEFAULTS;
        } catch {
          return DEFAULTS;
        }
      });

      const [mode, setMode] = useState("work"); // 'work' | 'short' | 'long'
      const [running, setRunning] = useState(false);
      const [remainingSec, setRemainingSec] = useState(() => settings.work * 60);
      const [completedPomodoros, setCompletedPomodoros] = useState(0);
      const [showSettings, setShowSettings] = useState(false);

      const intervalRef = useRef(null);
      const startTimestampRef = useRef(null);
      const lastTickRemainingRef = useRef(remainingSec);

      // persist settings
      useEffect(() => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      }, [settings]);

      // persist state
      useEffect(() => {
        const state = { mode, remainingSec, running, completedPomodoros };
        localStorage.setItem(STATE_KEY, JSON.stringify(state));
      }, [mode, remainingSec, running, completedPomodoros]);

      // load state
      useEffect(() => {
        try {
          const s = localStorage.getItem(STATE_KEY);
          if (!s) return;
          const parsed = JSON.parse(s);
          setMode(parsed.mode || "work");
          setRemainingSec(typeof parsed.remainingSec === 'number' ? parsed.remainingSec : settings.work * 60);
          setRunning(!!parsed.running);
          setCompletedPomodoros(parsed.completedPomodoros || 0);
        } catch {}
      }, []);

      // sync when durations change and not running
      useEffect(() => {
        if (!running) setRemainingSec(getDurationSec(mode, settings));
      }, [settings.work, settings.short, settings.long, mode]);

      // timer loop
      useEffect(() => {
        if (!running) return;
        if (intervalRef.current) window.clearInterval(intervalRef.current);

        startTimestampRef.current = performance.now();
        const startingRemaining = remainingSec;
        lastTickRemainingRef.current = startingRemaining;

        intervalRef.current = window.setInterval(() => {
          const elapsedMs = performance.now() - (startTimestampRef.current || performance.now());
          const newRemaining = Math.max(0, Math.round(startingRemaining - elapsedMs / 1000));

          if (newRemaining !== lastTickRemainingRef.current) {
            setRemainingSec(newRemaining);
            lastTickRemainingRef.current = newRemaining;
          }

          if (newRemaining <= 0) {
            window.clearInterval(intervalRef.current);
            intervalRef.current = null;
            setRunning(false);
            onComplete();
          }
        }, 250);

        return () => {
          if (intervalRef.current) window.clearInterval(intervalRef.current);
        };
      }, [running]);

      // keyboard shortcuts
      useEffect(() => {
        function onKey(e) {
          if (e.target && e.target.tagName === 'INPUT') return;
          if (e.code === 'Space') {
            e.preventDefault();
            toggle();
          } else if (e.key && e.key.toLowerCase() === 'n') {
            e.preventDefault();
            next();
          } else if (e.key && e.key.toLowerCase() === 'r') {
            e.preventDefault();
            reset();
          } else if (["1", "2", "3"].includes(e.key)) {
            const m = e.key === '1' ? 'work' : e.key === '2' ? 'short' : 'long';
            changeMode(m);
          }
        }
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      });

      // ask notification permission once
      useEffect(() => {
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission();
        }
      }, []);

      function notify(title, body) {
        try {
          if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(title, { body });
          }
        } catch {}
      }

      function beep() {
        try {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          const ctx = new Ctx();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = 'sine';
          o.frequency.value = 880;
          o.connect(g);
          g.connect(ctx.destination);
          g.gain.setValueAtTime(0.0001, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.25);
          o.start();
          o.stop(ctx.currentTime + 0.25);
        } catch {}
      }

      function getDurationSec(m, s) {
        return (m === 'work' ? s.work : m === 'short' ? s.short : s.long) * 60;
      }

      function changeMode(m) {
        setMode(m);
        setRunning(false);
        setRemainingSec(getDurationSec(m, settings));
      }

      function toggle() { setRunning(r => !r); }
      function reset() { setRunning(false); setRemainingSec(getDurationSec(mode, settings)); }

      function next() {
        if (mode === 'work') {
          const nextCount = completedPomodoros + 1;
          setCompletedPomodoros(nextCount);
          const shouldLong = nextCount % Math.max(1, settings.longEvery) === 0;
          const nextMode = shouldLong ? 'long' : 'short';
          setMode(nextMode);
          setRemainingSec(getDurationSec(nextMode, settings));
          setRunning(settings.autoStart);
        } else {
          setMode('work');
          setRemainingSec(getDurationSec('work', settings));
          setRunning(settings.autoStart);
        }
      }

      function onComplete() {
        beep();
        if (mode === 'work') {
          const nextCount = completedPomodoros + 1;
          setCompletedPomodoros(nextCount);
          const shouldLong = nextCount % Math.max(1, settings.longEvery) === 0;
          const nextMode = shouldLong ? 'long' : 'short';
          notify('Work session done!', shouldLong ? 'Time for a long break.' : 'Time for a short break.');
          setMode(nextMode);
          setRemainingSec(getDurationSec(nextMode, settings));
          setRunning(settings.autoStart);
        } else {
          notify('Break finished', 'Back to focus ✨');
          setMode('work');
          setRemainingSec(getDurationSec('work', settings));
          setRunning(settings.autoStart);
        }
      }

      const totalSec = useMemo(() => getDurationSec(mode, settings), [mode, settings]);
      const progress = 1 - remainingSec / totalSec;

      const mm = String(Math.floor(remainingSec / 60)).padStart(2, '0');
      const ss = String(Math.floor(remainingSec % 60)).padStart(2, '0');

      return (
        <div className="min-h-screen w-full bg-neutral-950 text-neutral-100 flex items-center justify-center p-6">
          <div className="w-full max-w-3xl">
            <header className="flex items-center justify-between mb-6">
              <h1 className="text-2xl sm:text-3xl font-semibold tracking-tight">Pomodoro</h1>
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setShowSettings(s => !s)}
                  className="px-3 py-2 text-sm rounded-xl bg-neutral-800 hover:bg-neutral-700 transition"
                >
                  {showSettings ? 'Close' : 'Settings'}
                </button>
              </div>
            </header>

            <div className="grid md:grid-cols-2 gap-6">
              <div className="bg-neutral-900 rounded-2xl p-6 shadow-xl">
                <ModeTabs mode={mode} onChange={changeMode} />

                <div className="flex items-center justify-center my-6">
                  <ProgressRing progress={progress} label={`${mm}:${ss}`} />
                </div>

                <div className="flex items-center justify-center gap-3">
                  <button
                    onClick={toggle}
                    className="px-5 py-3 rounded-2xl shadow bg-white text-neutral-900 font-medium hover:opacity-90"
                  >
                    {running ? 'Pause' : 'Start'}
                  </button>
                  <button onClick={reset} className="px-4 py-3 rounded-2xl bg-neutral-800 hover:bg-neutral-700">Reset</button>
                  <button onClick={next} className="px-4 py-3 rounded-2xl bg-neutral-800 hover:bg-neutral-700">Next</button>
                </div>

                <div className="mt-5 text-center text-sm text-neutral-400">
                  <p>Completed pomodoros: <span className="text-neutral-200 font-medium">{completedPomodoros}</span></p>
                  <p className="mt-1">Shortcuts: Space · N Next · R Reset · 1 Work · 2 Short · 3 Long</p>
                </div>
              </div>

              <div className="bg-neutral-900 rounded-2xl p-6 shadow-xl">
                {showSettings ? (
                  <SettingsPanel settings={settings} setSettings={setSettings} />
                ) : (
                  <Tips />
                )}
              </div>
            </div>
          </div>
        </div>
      );
    }

    function ModeTabs({ mode, onChange }) {
      const tabs = [
        { key: 'work', label: 'Work' },
        { key: 'short', label: 'Short' },
        { key: 'long', label: 'Long' },
      ];
      return (
        <div className="flex items-center bg-neutral-800 rounded-xl p-1">
          {tabs.map(t => (
            <button key={t.key} onClick={() => onChange(t.key)}
              className={`flex-1 px-3 py-2 rounded-lg text-sm transition ${mode === t.key ? 'bg-neutral-200 text-neutral-900 font-medium' : 'text-neutral-300 hover:text-white'}`}>
              {t.label}
            </button>
          ))}
        </div>
      );
    }

    function SettingsPanel({ settings, setSettings }) {
      function upd(k, v) { setSettings({ ...settings, [k]: v }); }
      return (
        <div className="space-y-5">
          <h2 className="text-lg font-semibold">Settings</h2>
          <div className="grid grid-cols-2 gap-4 text-sm">
            <NumberField label="Work (min)" value={settings.work} onChange={n => upd('work', clampInt(n, 1, 180))} />
            <NumberField label="Short Break (min)" value={settings.short} onChange={n => upd('short', clampInt(n, 1, 60))} />
            <NumberField label="Long Break (min)" value={settings.long} onChange={n => upd('long', clampInt(n, 1, 90))} />
            <NumberField label="Long break every" value={settings.longEvery} onChange={n => upd('longEvery', clampInt(n, 1, 12))} />
            <ToggleField label="Auto-start next session" checked={settings.autoStart} onChange={b => upd('autoStart', b)} />
          </div>
          <p className="text-neutral-400 text-xs">Settings persist locally in your browser.</p>
        </div>
      );
    }

    function NumberField({ label, value, onChange }) {
      return (
        <label className="flex flex-col gap-1">
          <span className="text-neutral-300">{label}</span>
          <input type="number" className="bg-neutral-800 rounded-lg px-3 py-2 outline-none focus:ring-2 ring-neutral-500"
            value={value} onChange={e => onChange(Number(e.target.value))} />
        </label>
      );
    }

    function ToggleField({ label, checked, onChange }) {
      return (
        <label className="flex items-center justify-between col-span-2 bg-neutral-800 rounded-lg px-3 py-2 cursor-pointer select-none">
          <span className="text-neutral-300">{label}</span>
          <input type="checkbox" checked={checked} onChange={e => onChange(e.target.checked)} className="w-5 h-5" />
        </label>
      );
    }

    function Tips() {
      return (
        <div className="space-y-4">
          <h2 className="text-lg font-semibold">How it works</h2>
          <ul className="list-disc list-inside text-sm text-neutral-300 space-y-1">
            <li>Pick a mode, press <span className="font-medium text-neutral-100">Start</span>.</li>
            <li>When a session ends, you get a gentle beep and a desktop notification.</li>
            <li>Every N work sessions, you get a longer break.</li>
            <li>Use keyboard shortcuts for speed: Space / N / R / 1-3.</li>
          </ul>
          <div className="text-xs text-neutral-400">Pro-tip: enable site notifications when prompted so you don’t miss session switches.</div>
        </div>
      );
    }

    function ProgressRing({ progress, label }) {
      const size = 220;
      const stroke = 14;
      const r = (size - stroke) / 2;
      const c = 2 * Math.PI * r;
      const offset = c * (1 - Math.min(1, Math.max(0, progress)));
      return (
        <div className="relative" style={{ width: size, height: size }}>
          <svg width={size} height={size} className="rotate-[-90deg]">
            <circle cx={size / 2} cy={size / 2} r={r} stroke="#27272a" strokeWidth={stroke} fill="none" />
            <circle cx={size / 2} cy={size / 2} r={r} stroke="#e5e7eb" strokeWidth={stroke} strokeLinecap="round"
              strokeDasharray={c} strokeDashoffset={offset} fill="none" className="transition-[stroke-dashoffset] duration-200 ease-linear" />
          </svg>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-5xl font-light tracking-tight">{label}</div>
          </div>
        </div>
      );
    }

    function clampInt(n, min, max) { return Math.min(max, Math.max(min, Math.round(n))); }

    ReactDOM.createRoot(document.getElementById('root')).render(<PomodoroApp />);
  </script>
</body>
</html>
